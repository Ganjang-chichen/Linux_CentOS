
# 리눅스 시스템의 이해

## 목차

[2.1 리눅스와 하드웨어](#리눅스와-하드웨어)

[2.1.1 하드웨어의 이해](#하드웨어의-이해)

## 2.1
## 리눅스와 하드웨어

### 2.1.1
### 하드웨어의 이해

    리눅스 설치 및 운영에 있어 CPU, 메모리, 하드디스크 등에 대한 정보는 필수 정보이다.

    CPU
        사용하고자 하는 배포판의 CPU 지원 여부를 확인해서 리눅스를 설치해야 한다.

    RAM (메모리)
        최근에는 대부분의 메모리를 잘 지원하여 종료에 따른 문제점은 거의 발생하지 않는다.
        그러나 메모리 용량은 정확히 알고 있어야 한다.
        스왑 파티션 설정과 관련있기 때문이다.

    하드 디스크 드라이브
        최근 리눅스 배포판에서는 대부분의 하드디스크 드라이브를 지원한다.
        그러나 어떤 디스크를 사용하는지는 알고 있어야 한다.
        왜냐하면 파티션이나 스왑 설정 등에서 하드디스크 종류에 따라 파일명이 달라진다.
        EX) IDE 디스크 : /dev/hdam, SCSI, S-ATA SSD 등 : dev/sda | /dev/sdb

    모니터와 비디오 어댑터
        텍스트 기반의 콘솔 환경에서는 모니터와 비디오 카드의 역할이 크게 중요하지 않다.
        그러나 X-Window 기반의 GUI 환경에서는 정확한 정보가 필요하다.

    네트워크 인터페이스
        리눅스는 네트워크 환경을 기반으로 사용하기 때문에 네트워크 인터페이스 설정은 필수이다.
        그러나 리눅스는 기본적으로 대부분의 네트워크 인터페이스를 지원한다.

    키보드 및 마우스
        리눅스는 현재 존재하는 키보드와 마우스를 대부분 지원한다.

### 2.1.2
### 하드웨어의 선택

    RAID (Redundant Array of Independent[Inexpensive] Disks)
        여러 개의 하드디스크가 있을 때 동일한 데이터를 다른 위치에 중복해서 저장하는 방법이다.
        데이터를 여러 개의 디스크에 저장하여 입출력 작업이 균형을 이루게 되어 전체적 성능 향상된다.
        운영체제에서 RAID는 논리적으로 하나의 디스크로 인식하여 처리된다.

    RAID 이용
    > 백업을 가능
    > 안정적인 데이터의 보존과 유지 가능
    > 속도향상

    RAID 기술
    1. 스트라이핑(Striping)
        연속된 데이터를 여러 개의 디스크에 라운드로빈 방식으로 기록하는 기술이다.

    2. 미러링(Mirroring)
        디스크에 에러가 발생 시 데이터의 손실을 막기 위해 
        추가적으로 하나 이상의 장치에 중복 저장하는 기술

### 2.1.3
### RAID의 종류

|종류|특징|단점|
|---|---|---|
|RAID-0|* 스트라이핑 기술을 사용하여 빠른 입출력 속도를 제공한다. <br>* 데이터를 중복이나 페리티 없이 디스크에 본산하여 기록한다. <br>* 처리속도가 빠르다|* 구성된 디스크 중에 하나라도 오류가 발생하면 데이터 복구가 불가하다.|
|RAID-1|* 미러링 기술을 이용하여 두 개의 디스크에 데이터를 동일하게 기록한다. <br>* 스트라이핑 기술은 사용안한다. <br>* 각 드라이브를 동시에 읽을 수 있어서 읽기 성능이 향상된다.|* 중복저장으로 인한 디스크 낭비가 50%에 이른다. <br>*  쓰기성능은 단일 디스크와 같다.|
|RAID-2|* 디스크들은 스트라이핑 기술을 사용하고 구성된다. <br>* 디스크들의 에러를 감지하고 수정하기 위해 ECC 정보를 사용한다.||
|RAID-3|* 스트라이핑 기술을 사용한다. <br>* 패리티 정보를 저장하기 위해 별도의 하나의 디스크를 사용한다. <br> 보통 대형 레코드가 많은 시스템에서 사용된다.|* 입출력작업이 동시에 모든 디스크에 이루어 지기 때문에 입출력을 겹치게 할 수 없다.|
|RAID-4|* 블록 형태의 스트라이핑 기술을 사용하여 디스크를 구성한다. <br>* 데이터를 읽을 때 중첩 입출력이 가능하다. |* 쓰기작업은 패리티 연산을 해야되고 패리티 디스크에 저장해야되기 때문에 입출력의 중첩이 불가능하고, 병목현상이 발생할 수 있다.|
|RAID-5|* 최소 3개의 디스크로 구성해야 된다. <br>* 패리티 정보를 이용하여 하나의 디스크가 고장이 발생할 경우에도 사용이 가능한 방식이다. <br>* 구성된 디스크에 분산하여 기록하나, 중복저장하진 않는다. <br>* 가장 보편적이로 사용된다. <br>* 작고 랜덤한 입출력이 많은 경우에 더 나은 성능을 발휘한다. <br>* RAID-0,1 의 단점을 보완하였다. <br>* 디스크의 개수를 늘릴수록 저장 공간의 효율성이 높아진다. <br>* 1개의 디스크 오류에 대처 가능하다.|* 2개이상의 디스크 오류 발생 시 데이터를 복구 할 수 없다.|
|RAID-6|* 전체적인 구성은 RAID-5와 비슷하지만 디스크에 2차 패리티 구성을 포함함으로써 매우 높은 고장대비 능력을 발휘한다. <br>* 2개의 디스크 오류에도 데이터를 읽을 수 있다. <br>* RAID-5에 비하여 데이터에 대한 신뢰도가 높다.|* RAID-5 에 비하여 디스크 공간 효율성은 떨어진다. <br>* RAID-5에 비하여 처리속도가 떨어진다.|
|RAID-7|* 하드웨어 컨트롤러에 내장되어 있느 실시간 운영체제를 이용하여 구성하는 방식이다. <br>* 독자적인 여러가지 특성들을 제공한다.||
|RAID 0+1|* 디스크 2개를 RAID-0의 스트라이핑 기술로 구성 후 RAID-1의 미러링으로 구성하는 방식이다. <br>* 최소 4개의 디스크가 필요하다.||
|RAID-10|* RAID- 0+1의 반대 개념으로써 디스크 2개를 미러링으로 구성 후 다시 스트라이핑 하는 방식이다.||
|RAID-53|* RAID-3 방식에 별도로 스트라이프 어레이를 구성하는 방식이다. <br>* RAID-3 보다 높은 성능을 제공한다.|* 구성 비용이 많이 든다.|

### 2.1.4
### LVM

    LVM (Logical Volume Manager) 개요
    여러 하드 디스크의 파티션을 분할 및 병합 하는 기능이다.

    용어
    1. 물리적 볼륨 (PV:Physical Volume)
        실제 디스크에 물리적으로 분할한 파티션이다.
    2. 볼륨그룹 (VG:Volume Group)
        물리적 볼륨이 모여서 생성하는 덩어리다.
        PE가 모여서 생성되는 하나의 큰 덩어리이다.
    3. 논리적 볼륨 (Logical Volume)
        VG 에서 사용자가 필요한 만큼 할당하여 만들어지는 공간이다.
        물리적 디스크에서 분할하여 사용하는 파티션이라고 보면된다.
    4. 물리적 확장 (PE:Physical Extent)
        PV 에서 나누어 사용하는 일종의 블록 같은 영역이다.
        보통 1 PE 가 4 MB 정도씩 할당된다.

### 2.1.5
### 리눅스의 구조

    부트매니저
        부트 로더라고 불리기도 하며, 부팅을 도와주는 역할을 하는 프로그램으로 특히 한 컴퓨터에 
        리눅스, 윈도우 등 운영체제가 설치되어 있을 경우에 선택하여 부팅할 수 있도록 해준다.
        하드디스크의 MBR(Master Boot Record) 에 설치된다.

    LILO (Linux Loader)
        리눅스용 부트 매니저 프로그램이다.
        최근에는 잘 사용 안한다.

    GRUB (Grand Unified BootLoader)
        GNU 프로젝트에서 만든 부트로더이다.
        다양한 파일 시스템을 지원한다.
        부팅 시 커널인자를 조정하여 동적인 부팅을 지원한다.
        그래픽 매뉴와 배경그림 삽입이 가능하다.

    GRUB의 부트화면
        그래픽 메뉴 목록 형식으로 지원된다.
        레드헷 계열에서는 하나의 운영체제만 설치되어있을 시 목록을 보여주지 않는다.
        위의 경우, 특정 키를 입력해야 GRUB 부트화면에 접근 할 수 있다.
        제시된 목록에서 상하 방향키를 통해 OS를 바꿀 수 있고 [Enter] 키를 통해 선택 및 부팅한다.
        메뉴 화면에서 [a], [e], [c] 키를 통해 커널인자를 조정을 통한 다양한 부팅모드를 제공한다.

    [a] 키
    grub.conf 에서 kernel과 관련된 부분의 매개 변수를 추가할 수 있게 해준다.
    [a]키 입력 후, 맨뒤에 single 또는 1을 입력하여 싱글모드로 진입할 수 있다.

    [e] 키
    grub.conf에 등록된 부팅 목록의 모든 항목을 직접 편집할 수 있도록 해준다.
    편집중 [ESC] 키를 통해 초기값으로 바꿀 수 있다.
    메뉴를 편집한다해서 grub.conf의 내용이 바뀌는 것이 아닌 현재 부팅시에만 일시적으로 적용된다.
    편집모드에서 지원하는 키
        e : 커서가 위치한 줄을 편집한다.
        d : 커서가 위치한 줄을 삭제한다.
        o : 명령줄을 커서가 위치한 줄의 아래에 추가한다.
        O : 명령줄을 커서가 위치한 줄의 위에 추가한다.
        b : 부팅을 시작한다. (최종 편집 후 부팅할 때 사용)
    
    [c] 키
    상호대화식으로 직업 입력할 수 있는 모드이다.
    사용방법은 명령어를 입력하는 환경이 Bash Shell과 유사하다.

    grub.conf
        #boot=/dev/sda 
            부팅이 되는 하드디스크를 지정하는 항목이다.
            시스템에 장착된 디스크가 하나인 경우 주석처리된다.
        default=0
            전원을 켰을 때 기본적으로 부팅되는 운영체제를 설정하는 항목
            GRUB 메뉴화면에서 선택하지 않았을 때 이 값을 기준으로 선택된다.
            이 값은 grub.conf에 나열된 title 순이다.
        timeout=10
            GRUB 메뉴화면에서 대기 시간으로 단위는 초이다.
            대기시간이 지나면 default의 OS가 부팅된다.
            이 부분이 주석처리되거나 항목이 없으면 반드시 [Enter] 키로 선택해야 부팅된다.
        splashimage=(hd0,3)/boot/grub/splash.xpm.gz
            GRUB 화면의 배경 이미지를 지정하는 부분이다.

### 2.1.6
### 디렉터리 구조 및 역할

    디렉터리(Directory)의 개요
    리눅스에서 디렉터리는 최상위에 해당하는 루트(/)중심으로
    하위 디렉터리에 다수의 디렉터리가 존재하는 형태의 트리구조로 계층적으로 관리된다.

    /           : 최상위에 있는 디렉터리로 루트 디렉터리라 한다.

    /bin        : 일반적으로 bin은 binary의 약자로 실행 파일들이 들어있다.
                > cp, mkdir, mv, rm 등의 명령어 들이 들어있는 디렉터리로 보통 PATH가 설정되어있다.

    /boot       : 부팅 이미지 파일이나 커널 등 시스템 부팅 시 필요한 파일, grub 관련 파일이 들어있는 파일이다.

    /dev        : 하드디스크, CD-ROM, 터미널 등과 같이 
                > 실제로 존재하는 물리적인 장치 등을 파일화해 관리하는 디렉터리이다.

    /etc        : 이 디렉터리에는 시스템 환경 설정 파일 및 부팅과 관련된 여러 가지 스크립트 파일들이 들어있다.
                > 이들 파일에 설정된 내용을 읽어서 관련 프로그램들이 실행하게 된다.

    /home       : 개인 사용자들이 파일이나 디렉터리를 만들어서 사용할 수 있는 홈 디렉터리가 위치한다.

    /lib        : 각종 라이브러리가 저장되어 있는 디렉터리로 커널 모듈도 이 디렉터리에 들어있다.

    /mnt        : CD-ROM, 플로피디스크, 하드디스크, 네트워크 파일 시스템 등을 마운트할 때 포인터가 되는 디렉터리이다.
                > 최근 버전에는 /media, /net 등을 추가로 제공하고 있다.

    /misc       : 자동 마운트 프로그렘인 autofs에 의해 사용되는 디렉터리이다.

    /opt        : 응용 프로그램들의 설치를 위해 사용되는 디렉터리이다.

    /proc       : 가상 파일 시스템으로 시스템에서 운영되고 있는 다양한 프로세스의 상태, 하드웨어, 기타 시스템 정보를 가지고 있다.

    /root       : 시스템 관리자인 root 사용자의 홈 디렉터리이다.
    
    /sbin       : System Binary의 약자로, 주로 시스템 관리에 대한 명령어들이 들어있는 디렉터리이다.
                > 보통 root 사용자가 사용하며, 시스템종료, 네트워크 인터페이스 설정, 시스템 점검 및 복구 등의 명령들이 들어있다.

    /tmp        : 임시 저장 디렉터리로서 각종 프로그램이나 소켓파일, 프로세스 작업을 할 때 
                > 임시로 생성되는 파일을 저장하는 디렉터리이다.

    /usr        : 시스템 운영에 필요한 명령, 응용 프로그램들이 위치하는 디렉터리이다.
                > 커널소스, C 언어 헤더 파일, C-컴파일러와 같은 개발도구 ,MYSQL 등이 모두 이 디렉터리 하위 디렉터리에 설치된다.
    /var        : 시스템 운영 로그 파일과 스풀링과 같은 가변적인 데이터를 보관하는 디렉터리이다.

    /media      : 이동식 장치인 cdrom, floppy 등을 마운트 하기 위해 제공되는 디렉터리이다.

    /selinux    : RHEL 4 부터 보안 강화를 위해 사용되는 SELLinux 관련 디렉터리이다.

    /srv        : 사이트에서 생성되는 데이터를 저장하는 디렉터리이다.
    
    /sys        : 2.6 커널에서 사용되는 가상 파일 시스템인 sysfs에서 사용하는 디렉터리이다.
                > proc디렉터리에서 보다 계층적인 구조로 하드웨어 정보를 제공한다.

    /cgroup     : cgroup(control group)은 시스템 상에 동작중인 태스크들을 임의로 그룹지어 제어할 수 있도록 
                > 도와주는 기능을 제공하는데, 이와 관련된 정보를 담고 있는 디렉터리이다.

    /lib64      : 64비트용 리눅스를 설치하는 경우에 생성되는 디렉터리로 64비트 기반의 라이브러리 관련 디렉터리이다.

    /run        : 부팅 이후에 동작중인 프로세스의 런타임(Runtime) 데이터를 저장하고 있는 디렉터리이다.

<img src="../images/02/216root_directory.png">

### 2.1.7
### 부팅과 셧다운

    부팅은 컴퓨터의 전원이 켜진 후 운영체제가 가동되어 사용자가 컴퓨터를 사용할 수 있도록 만들어주는 과정이다.
    부팅은 두 가지의 단계를 거친다.
    1. 하드웨어적 단계
        시스템에 장착된 하드웨어를 인식하고 점검하는 단계
    2. 소프트웨어적 단계
        사용자가 운영체제를 사용하고 다양한 응용 프로그램을 사용할 수 있도록 메모리에 상주시키는 단계

    
    하드 디스크에 설치된 운영체제의 부팅과정
    
    1. 컴퓨터 전원을 켜면 바이오스는 컴퓨터에 장착된 하드웨어를 점검한다.
    2. 바이오스는 하드웨어가 검사가 끝나면 CMOS에 설정된 첫 번째 부팅 하드디스크를 확인한다.
    3. 첫 번째 하드디스크의 MBR 영역에 있는 부트 매니저 프로그램을 실행한다.
    4. 부트 매니저 프로그램은 관련 환경 설정 파일을 참고하여 운영체제 부팅을 시작한다.

    리눅스의 부팅 과정

    1. 리눅스 부팅의 하드웨어 인식 단계
    부트 매니저 프로그램인 grub가 시작되면 리눅스 설치 시에 인식된 하드웨어 설정대로 부팅을 진행한다.

    2. 리눅스 부팅의 소프트웨어 구동 단계
    